---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# larus

<!-- badges: start -->
<!-- badges: end -->


## Installation

You can install the development version of larus from [GitHub](https://github.com/) with:

```{r,eval=FALSE}
# install.packages("devtools")
devtools::install_github("MiriamLL/larus")
```


# Intro

There is three key issues in determining the foraging trips in GSMs attached to gulls:

 1. Battery charge and gaps (intervals) in the data
 2. Identify foraging trips, classify is usable or not
 3. The gulls just do whatever they want. 

# --------------------

# 1. The effect of the battery

```{r,echo=FALSE,eval=FALSE}
load("~/03Academico/02Proyectos-Postdoc/2025/1Programming/2Packages/larus/data/LALI_example.rda")
GSM_battery<-GSM_battery %>%
  rename(battery_charge=battery.charge.percent,
         gaps_min=Gaps_time)%>%
  select(ID,daytime,season,month,battery_charge,gaps_min)
#Move to folder data
save(GSM_battery, file = "GSM_battery.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("GSM_battery")
devtools::document()
devtools::check()
```

```{r}
library(larus)
```

```{r}
head(GSM_battery)
```


```{r, message=FALSE}
library(scales)
library(ggplot2)
```

```{r,eval=FALSE}
ggplot(GSM_battery, aes(x=daytime, y=battery_charge)) +
  geom_line() +
  scale_x_datetime(labels = date_format("%b"),date_breaks = "1 month")
```

## Battery levels classification

Considerations:
Optimal battery was considered > 75% battery 
Good < 75% battery 
Poor < 50% battery 
Low  < 25% battery 

```{r, message=FALSE}
library(tidyverse)
```

```{r}
GSM_battery <- GSM_battery%>%
  mutate(battery_class = 
         case_when(is.na(battery_charge) ~ 'U',
                   battery_charge >= 75 ~ '1Optimal (>75%)',
                   battery_charge <= 75 & battery_charge > 50 ~ '2Good (>50%)',
                   battery_charge <= 50 & battery_charge > 25 ~ '3Poor (>25%)',
                   battery_charge <= 25 ~ '4Low (<25%)',
                   TRUE ~ 'Check'))
```

```{r}
Battery_classes <-GSM_battery %>%
  group_by(battery_class)%>%
  tally()%>%
  mutate(total=sum(n))%>%
  mutate(prop=n*100/total)
Battery_classes
```

## Gaps and battery relations

When studying tracking locations from GSM data, especially in the case of birds like gulls, it’s common to encounter gaps in the data due to factors such as loss of signal, battery limitations, or movement through areas with poor GSM coverage. 

Calculate gaps

```{r}
library(larus)
```

if there is only one individual

```{r}
GSM_locs$gaps_min<-as.numeric(GSM_locs$daytime - lag(GSM_locs$daytime))
```

```{r}
head(GSM_locs)
```

```{r, echo=FALSE, eval=FALSE}
calculate_gaps<-function(my_locs=my_locs,
                         my_datetime=my_datetime,
                         my_separator=my_separator){

  my_locs$my_separator<-(my_locs[[my_separator]])

  trips_list<-split(my_locs,my_locs$my_separator)

  gaps_list<-list()

  #obtiene para cada elemento de la lista
  for( i in seq_along(trips_list)){

    trip_df<-trips_list[[i]]

    times<-trip_df[[my_datetime]]
    times_lag<-dplyr::lag(times)
    time_dif<-as.numeric(difftime(times,times_lag, units="mins"))
    trip_df$timedif_min<-round(time_dif,2)

    gaps_list[[i]]<-trip_df

  }

  gaps_df<- do.call("rbind",gaps_list)

  gaps_df$my_separator<-NULL

  return(gaps_df)
}
```

If there are more individuals

```{r}
GSM_battery<-calculate_gaps(my_locs = GSM_locs,my_datetime = 'daytime',my_separator = 'ID')
```

Considerations:
Optimal gaps < 5 minutes 
Good < 15 minutes
Average < 30 minutes
Poor < 2 hours (120 minutes)
Low  > 24 hours (1400 minutes)

```{r}
Battery_gaps <- GSM_battery %>%
  mutate(gaps_class = 
           case_when(is.na(gaps_min) ~ '8U',
                     gaps_min <= 5 ~ '1Optimal (<5mins)',
                     gaps_min >= 5 & gaps_min < 15 ~ '2Good (<15mins)',
                     gaps_min >= 15 & gaps_min < 30 ~ '3Average (<30mins)',
                     gaps_min >= 30 & gaps_min < 60 ~ '4Poor (<1hr)',
                     gaps_min >= 60 & gaps_min < 1400 ~ '5Low (>1hr)',
                     gaps_min >= 1400 ~ '6Low (onceAday)',
                     TRUE ~ '7Check'))
```

```{r}
Battery_gaps %>%
  group_by(gaps_class)%>%
  tally()
```

## Compare 

```{r}
library(patchwork)
```

### Battery and gaps per season

```{r, fig.height=4, fig.width=6}
Battery_gaps%>%
  group_by(season,battery_class)%>%
  tally()%>%
  mutate(total=sum(n))%>%
  mutate(prop=n*100/total) %>%
  
ggplot(aes(fill=battery_class, y=prop, x=season)) + 
  geom_bar(stat="identity")+
  scale_fill_manual(values=c('#d7263d','#f46036','#2e294e'))+
  theme_classic()+
  scale_y_continuous(expand = c(0,0)) +
  
Battery_gaps %>%
  group_by(season,gaps_class)%>%
  tally()%>%
  mutate(total=sum(n))%>%
  mutate(prop=n*100/total)%>%
  filter(gaps_class!='8U') %>% #expect first position to be empty
  
ggplot(aes(fill=gaps_class, y=prop, x=season)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values=c('#d7263d','#f46036','#ffc857','#c5d86d','#1b998b','#2e294e'))+
  theme_classic()+
  scale_y_continuous(expand = c(0,0)) +
  
plot_layout(ncol = 1)
```

### Battery and gaps per month

```{r, fig.height=4}
Battery_gaps%>%
  group_by(month,battery_class)%>%
  tally()%>%
  mutate(total=sum(n))%>%
  mutate(prop=n*100/total) %>%
  
ggplot(aes(fill=battery_class, y=prop, x=month)) + 
  geom_bar(stat="identity")+
  scale_fill_manual(values=c('#d7263d','#f46036','#2e294e'))+
  theme_classic()+
  scale_y_continuous(expand = c(0,0)) +
  
Battery_gaps %>%
  group_by(month,gaps_class)%>%
  tally()%>%
  mutate(total=sum(n))%>%
  mutate(prop=n*100/total)%>%
  filter(gaps_class!='8U') %>% #expect first position to be empty
  
ggplot(aes(fill=gaps_class, y=prop, x=month)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values=c('#d7263d','#f46036','#ffc857','#c5d86d','#1b998b','#2e294e'))+
  theme_classic()+
  scale_y_continuous(expand = c(0,0)) +
  
plot_layout(ncol = 1)
```

# --------------------

## 2. Identify trips

### Step 1: subset month

```{r,echo=FALSE,eval=FALSE}
load("~/03Academico/02Proyectos-Postdoc/2025/1Programming/2Packages/larus/data/LALI_example.rda")
GSM_locs<-LALI03_02locs
GSM_locs<-GSM_locs %>%
  rename(battery_charge=battery.charge.percent,
         gaps_min=Gaps_time)%>%
  select(num_seq,
         ID,
         daytime,season,month,
         Longitude,Latitude,
         inside,central_base,
         battery_charge,gaps_min)
#Move to folder data
save(GSM_locs, file = "GSM_locs.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("GSM_locs")
devtools::document()
devtools::check()
```

```{r}
head(GSM_locs)
```

```{r, message=FALSE}
library(tidyverse)
```

```{r}
This_month<-'08'
This_month_text<-'Ago'
```

```{r}
Trips_01locs<-GSM_locs %>%
  dplyr::filter(month==This_month)
```

### Step 2: plot_check

```{r}
my_central_location<-data.frame(Longitude=-110.33979846296234,Latitude=24.28728834326802)
```

```{r, echo=FALSE,eval=FALSE}
usethis::use_r("plot_check")
plot_check<-function(my_locs=my_locs,my_central_location=my_central_location){
  ggplot2::ggplot()+
  ggplot2::geom_point(data = my_locs, ggplot2::aes(x=Longitude, y = Latitude),
             color='black',size = 0.8,alpha=0.4)+
  ggplot2::geom_point(data=my_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='red',shape=17, size=5)+
  ggplot2::geom_density_2d_filled(data = my_locs, ggplot2::aes(x = Longitude, y = Latitude),alpha = 0.5)+
  ggplot2::theme_bw()+
  ggplot2::theme(legend.position = 'none')+
  ggplot2::ggtitle('Check that the triangle is close to the highest location concentration- \nThis should be your central location-  \nIf the central location is shifted -  \nPlease recalculate using another central location')}
#' Creates a plot to check locations
#'
#' @param my_locs a data frame with locations
#' @param my_central_location a data frame with the central location
#'
#' @return plot to evaluate if the central location is correct
#' @export
#'
#' @examples plot_check(my_locs=GSM_locs,my_central_location = data.frame(Longitude=-110.34,Latitude=24.28))
plot_check<-function(my_locs=my_locs,my_central_location=my_central_location){
  ggplot2::ggplot()+
    ggplot2::geom_point(data = my_locs, ggplot2::aes(x=Longitude, y = Latitude),
                        color='black',size = 0.8,alpha=0.4)+
    ggplot2::geom_point(data=my_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='red',shape=17, size=5)+
    ggplot2::geom_density_2d_filled(data = my_locs, ggplot2::aes(x = Longitude, y = Latitude),alpha = 0.5)+
    ggplot2::theme_bw()+
    ggplot2::theme(legend.position = 'none')+
    ggplot2::ggtitle('Check that the triangle is close to the highest location concentration- \nThis should be your central location-  \nIf the central location is shifted -  \nPlease recalculate using another central location')}
usethis::use_package("ggplot2")

plot_check(my_locs=GSM_locs,my_central_location = data.frame(Longitude=-110.34,Latitude=24.28))
```

```{r}
plot_check(my_locs=Trips_01locs,my_central_location = my_central_location)
```

### Step 3: remove central locations

```{r}
Trips_02outside<-Trips_01locs %>%
  filter(inside=='outside_central')
```

### Step 4: trip_number_sequence

```{r,echo=FALSE, eval=FALSE}
usethis::use_r("continue_trip_sequence")

# ROXIGEN fill up
#' A function to calculate gaps between locations inside trips
#'
#' @param GPS_data the data containing date, time and trip number
#' @param column_datetime a column with date and time information already in POSIXct format
#' @param column_tripnumber a column with trip_number or any other separator
#'
#' @return the same data frame with an additional column called timedif_min
#' @export
#'
#' @examples Previous_params<-data.frame(trip_id=c("trip_00405"))
#' trip_number_sequence<-continue_trip_sequence(my_previous=Previous_params$trip_id)
#' 
continue_trip_sequence<-function(my_previous){
  print(dplyr::last(my_previous))
  trip_number_sequence<-substr(dplyr::last(my_previous), start = 6, stop = 10)
  trip_number_sequence<-as.numeric(trip_number_sequence)
  print(trip_number_sequence)
return(trip_number_sequence)}

# Run in console
devtools::document()
usethis::use_package("dplyr")
devtools::check()
```

```{r}
Previous_params<-data.frame(trip_id=c("trip_00405"))
```

```{r}
trip_number_sequence<-continue_trip_sequence(my_previous=Previous_params$trip_id)
```

```{r}
Trips_03trips<-Trips_02outside %>%
  mutate(num_seq=as.numeric(num_seq))%>%
  mutate(trip_number = (cumsum(c(1L, diff(num_seq)) !=   1L)))%>%
  mutate(trip_number = trip_number +1 + trip_number_sequence)%>%
  mutate(trip_number = stringr::str_pad(trip_number,  5, pad = "0"))%>%
  mutate(trip_number = paste0("trip_", trip_number))
```

### Step 5: plot_trips

function: plot_trips

```{r}
plot_trips<-function(my_locs=my_locs,my_central_location=my_central_location){
  ggplot()+
  geom_point(data = my_locs, aes(x=Longitude, y = Latitude,color=trip_number),
            size = 0.8,alpha=0.4)+
  geom_point(data=my_central_location, aes(x=Longitude, y=Latitude),color='red',shape=17, size=5)+
  geom_density_2d_filled(data = my_locs, aes(x = Longitude, y = Latitude),alpha = 0.1)+
  theme_bw()+
  theme(legend.position = 'none')+
  ggtitle('Here excludes all nest locations \nCheck if there is any pattern that suggest that the central location is shifted \nThis would include hotstops (brighter colors) in a specific area')}
```

```{r}
plot_trips(my_locs=Trips_03trips,my_central_location=my_central_location)
```

### Step 6: calculate_params

```{r, eval=FALSE, echo=FALSE}
GSM_trips<-Trips_03trips
GSM_trips<-GSM_trips %>%
  select(ID,trip_number,num_seq,
         daytime,season,month,
         Longitude,Latitude,
         inside,central_base,
         battery_charge,gaps_min)
#Move to folder data
save(GSM_trips, file = "GSM_trips.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("GSM_trips")
devtools::document()
devtools::check()
```

```{r, echo=FALSE, eval=FALSE}
usethis::use_r("calculate_params")
#' Calculates trip duration using locations, and gap intervals per trip
#'
#' @param my_locs a data frame with all locations
#' @param my_daytime the name of the column where day and time information is provided
#' @param my_format the format in the column POSTIXct
#' @param my_units pick "hours", "minutes", "seconds".
#' @param my_separator a column to separate trips, for example 'trip_number'
#'
#' @return regresa un nuevo data frame con la información del viaje, cuando inicio, cuando termino y la duración
#' @export
#'
# @examples GSM_params<-calculate_params(my_locs=GSM_trips,my_daytime='daytime',my_format="%Y-%m-%d %H:%M:%S",my_units="hours",my_separator="trip_number")
calculate_params<-function(my_locs=my_locs,
                           my_daytime=my_daytime,
                           my_format=my_format,
                           my_units=my_units,
                           my_separator=my_separator
){


  if (!is.null(my_locs[[my_separator]])) {
  }
  else {
    warning("Please check the name on the separator column")
  }
  if (!is.null(my_locs[[my_daytime]])) {
  }
  else {
    warning("Please check the name in my_daytime")
  }
  my_locs$my_separator <- (my_locs[[my_separator]])
  trips_list <- split(my_locs, my_locs$my_separator)
  duration_list <- list()
  for (i in seq_along(trips_list)) {
    trips_df <- trips_list[[i]]
    trip_start <- dplyr::first(trips_df[[my_daytime]])
    trip_end <- dplyr::last(trips_df[[my_daytime]])
    trip_id <- dplyr::first(trips_df[[my_separator]])
    duration_list[[i]] <- nest_loc <- data.frame(trip_id = trip_id,
                                                 trip_start = trip_start, trip_end = trip_end)
  }
  duration_merged <- do.call("rbind", duration_list)
  duration_merged$trip_start <- as.POSIXct(strptime(duration_merged$trip_start,
                                                    my_format), "GMT")
  duration_merged$trip_end <- as.POSIXct(strptime(duration_merged$trip_end,
                                                  my_format), "GMT")
  duration_merged$duration <- as.numeric(difftime(duration_merged$trip_end,
                                                  duration_merged$trip_start, units = my_units))

  gaps_params<-my_locs %>%
    dplyr::group_by(trip_number)%>%
    dplyr::summarise(min_gap=min(gaps_min),
              max_gap=max(gaps_min))%>%
    dplyr::rename(trip_id=trip_number)

  this_params<-gaps_params %>%
    dplyr::left_join(duration_merged,by='trip_id')%>%
    dplyr::select(trip_id,trip_start,trip_end,duration,min_gap,max_gap)

  return(this_params)
}
devtools::document()
devtools::check()
```

```{r}
Trips_03trips<-GSM_trips
Trips_04params<-calculate_params(my_locs=Trips_03trips,
                                 my_daytime='daytime',
                                 my_format=  "%Y-%m-%d %H:%M:%S",
                                 my_units="hours",
                                 my_separator="trip_number")
head(Trips_04params)
```

Define trip_month_id in case there are outliers and the locations need to be subset

```{r}
Trips_05params<-Trips_04params %>%
  mutate(trip_month_id=paste0(This_month_text,"_a_",trip_id))%>%
  mutate(central_loc='colony')
```

# Short: straight forward using functions

```{r}
This_month<-'08'
This_month_text<-'Ago'
```

```{r}
Trips_01locs<-GSM_locs %>%
  filter(month==This_month)
```

```{r, fig.height=4}
plot_check(my_locs=Trips_01locs,my_central_location=my_central_location)
```

```{r}
Trips_02outside<-Trips_01locs %>%
  filter(inside=='outside_central')
```

```{r}
Previous_params<-data.frame(trip_id=c("trip_00405"))
```

```{r}
trip_number_sequence<-continue_trip_sequence(my_previous=Previous_params$trip_id)
```

```{r}
Trips_03trips<-Trips_02outside %>%
  mutate(num_seq=as.numeric(num_seq))%>%
  mutate(trip_number = (cumsum(c(1L, diff(num_seq)) !=   1L)))%>%
  mutate(trip_number = trip_number +1 + trip_number_sequence)%>%
  mutate(trip_number = stringr::str_pad(trip_number,  5, pad = "0"))%>%
  mutate(trip_number = paste0("trip_", trip_number))
```

```{r, fig.height=4}
plot_trips(my_locs=Trips_03trips,my_central_location=my_central_location)
```

```{r}
Trips_04params<-calculate_params(my_locs=Trips_03trips,
                                 my_daytime='daytime',
                                 my_format=  "%Y-%m-%d %H:%M:%S",
                                 my_units="hours",
                                 my_separator="trip_number")
```

```{r}
range(Trips_04params$duration)
```

```{r, fig.height=4}
hist(Trips_04params$duration)
```

```{r}
Trips_05params<-Trips_04params %>%
  mutate(trip_month_id=paste0(This_month_text,"_a_",trip_id))%>%
  mutate(central_loc='colony')
```

```{r}
length(unique(Trips_05params$trip_id))
length(unique(Trips_03trips$trip_number))
```


# --------------------

# 3. Gulls just do whatever they want

## Step 1: classify_params

```{r, eval=FALSE, echo=FALSE}
GSM_params<-Trips_05params
GSM_params<-GSM_params %>%
  select(trip_id,trip_month_id,
         central_loc,
         trip_start,trip_end,
         min_gap,max_gap,
         duration)
#Move to folder data
save(GSM_params, file = "GSM_params.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("GSM_params")
devtools::document()
devtools::check()
```

```{r, eval=FALSE, echo=FALSE}
usethis::use_r("params_class")
params_class<-function(my_params=my_params){
  my_params<-my_params %>%
    mutate(trip_size = case_when(duration >= 0.5 ~ 'trip_longer_than_30mins',
                                 duration <= 0.5 ~ 'trip_shorter_than_30mins',
                                 TRUE ~ "other"))%>%
    
    mutate(resolution=case_when(max_gap >= 60 ~ 'low_resolution_gaps_more_60_mins',
                                max_gap <= 60 ~ 'ok_resolution_gaps_less_60_mins',
                                TRUE ~ "other"))%>%
    
    mutate(params_analyses=case_when(duration >= 24 ~ 'longer_than_24h_reevaluate_centralloc',
                                     duration <= 24 ~ 'shorter_than_24h_keep_centralloc',
                                     TRUE ~ "other"))%>%
    
    mutate(interpolation = case_when(duration <= 24 & max_gap <= 60 ~ 'gapsless60mins_shorter24hr_canditate_interpolate',
                                     duration >= 24 & max_gap >= 60 ~ 'gapsmore60mins_longer24hr_reevaluate_centralloc',
                                     duration >= 24 ~ 'onger24hr_reevaluate_centralloc',
                                     max_gap >= 60 ~ 'gapsmore60mins_dont_interpolate',
                                     TRUE ~ "other"))
  
  return(my_params)}
#' Add trip classification on the trip parameters
#'
#' @param my_params a data frame with trip parameters
#'
#' @return returns four new columns with criteria to keep or recalculate trip parameters
#' @export
#'
# @examples GSM_criteria<-params_class(my_params=GSM_params)
classify_params<-function(my_params=my_params){
  my_params<-my_params %>%
    dplyr::mutate(trip_size =  dplyr::case_when(duration >= 0.5 ~ 'trip_longer_than_30mins',
                                 duration <= 0.5 ~ 'trip_shorter_than_30mins',
                                 TRUE ~ "other"))%>%

    dplyr::mutate(resolution= dplyr::case_when(max_gap >= 60 ~ 'low_resolution_gaps_more_60_mins',
                                max_gap <= 60 ~ 'ok_resolution_gaps_less_60_mins',
                                TRUE ~ "other"))%>%

    dplyr::mutate(params_analyses= dplyr::case_when(duration >= 24 ~ 'longer_than_24h_reevaluate_centralloc',
                                     duration <= 24 ~ 'shorter_than_24h_keep_centralloc',
                                     TRUE ~ "other"))%>%

    dplyr::mutate(interpolation =  dplyr::case_when(duration <= 24 & max_gap <= 60 ~ 'gapsless60mins_shorter24hr_canditate_interpolate',
                                     duration >= 24 & max_gap >= 60 ~ 'gapsmore60mins_longer24hr_reevaluate_centralloc',
                                     duration >= 24 ~ 'onger24hr_reevaluate_centralloc',
                                     max_gap >= 60 ~ 'gapsmore60mins_dont_interpolate',
                                     TRUE ~ "other"))

  return(my_params)}

# Run in console
devtools::document()
devtools::check()
```

```{r}
Params_00criteria<-classify_params(my_params=GSM_params)
```

## Step 2: check_trip_criteria

Foraging trips were only considered when the animal was more than 1 km away from the colony and lasting longer than 30 min (Shaffer et al. 2017, Guerra et al. 2022). 

If trips had a gap of > 1hr and/or included overnight locations without a clear central location, they were excluded from the interpolation.

```{r, eval=FALSE, echo=FALSE}
Params_criteria<-Params_00criteria
#Move to folder data
save(Params_criteria, file = "Params_criteria.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("Params_criteria")
devtools::document()
devtools::check()
```

```{r, eval=FALSE, echo=FALSE}
check_trip_criteria<-function(my_params=my_params){
  
  trip_criteria<-my_params %>%
    dplyr::group_by(trip_size)%>%
    dplyr::tally()%>%
    dplyr::mutate(total=sum(n))%>%
    dplyr::mutate(prop=n*100/total)
  
   print(paste0("From ",sum(trip_criteria$n),' trips: ',
                round(trip_criteria$prop[1],2),' were ',trip_criteria$trip_size[1],' and ',
                 round(trip_criteria$prop[2],2),' were ',trip_criteria$trip_size[2],
                '. Trips shorter than 30 minutes are not considered real trips. Remove these trips from analyses. '
                ))
  
}
#' This function is just to provide a baseline information
#'
#' @param my_params a data frame with trip parameters
#'
#' @return prints information about your parameters
#' @export
#'
# @examples check_trip_criteria(my_params=Params_criteria)
check_trip_criteria<-function(my_params=my_params){

  trip_criteria<-my_params %>%
    dplyr::group_by(trip_size)%>%
    dplyr::tally()%>%
    dplyr::mutate(total=sum(n))%>%
    dplyr::mutate(prop=n*100/total)

  print(paste0("From ",sum(trip_criteria$n),' trips: ',
               round(trip_criteria$prop[1],2),' were ',trip_criteria$trip_size[1],' and ',
               round(trip_criteria$prop[2],2),' were ',trip_criteria$trip_size[2],
               '. Trips shorter than 30 minutes are not considered real trips. Remove these trips from analyses. '
  ))

}
```

```{r}
check_trip_criteria(my_params=Params_00criteria)
```

```{r}
Params_01criteria<-Params_00criteria %>%
  dplyr::filter(trip_size == 'trip_longer_than_30mins')
```

## Step 3: check_resolution_criteria

```{r, eval=FALSE, echo=FALSE}
Params_resolution<-Params_01criteria
#Move to folder data
save(Params_resolution, file = "Params_resolution.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("Params_resolution")
devtools::document()
devtools::check()
```

```{r, eval=FALSE, echo=FALSE}
usethis::use_r("check_resolution_criteria")
#' This function is just to provide a baseline information
#'
#' @param my_params a data frame with trip parameters
#'
#' @return prints information about your parameters
#' @export
#'
# @examples check_resolution_criteria(my_params=Params_resolution)

check_resolution_criteria<-function(my_params=my_params){
  
  resolution_criteria<-my_params %>%
    dplyr::group_by(resolution)%>%
    dplyr::tally()%>%
    dplyr::mutate(total=sum(n))%>%
    dplyr::mutate(prop=n*100/total)

  
  print(paste0("From ",sum(resolution_criteria$n),' trips: ',
                round(resolution_criteria$prop[1],2),' (n = ',resolution_criteria$n[1],') were ',
                                                                  resolution_criteria$resolution[1],' and ',
                 round(resolution_criteria$prop[2],2),' (n = ',resolution_criteria$n[2],') were ',
               resolution_criteria$resolution[2],
                '. Evaluate if trips with low resolution are to be kept'))
  
}
devtools::document()
devtools::check()
```

```{r}
check_resolution_criteria(my_params=Params_resolution)
```

## Step 4: check_lenght_criteria

```{r}
Params_02criteria<-Params_01criteria %>%
  dplyr::filter(resolution == 'ok_resolution_gaps_less_60_mins')
```

```{r, echo=FALSE, eval=FALSE}
usethis::use_r("check_length_criteria")
#' This function is just to provide a baseline information from the foraging trips
#'
#' @param my_params a data frame with trip parameters
#'
#' @return prints information about your parameters
#' @export
#'
# @examples check_length_criteria(my_params=Params_resolution)
check_length_criteria<-function(my_params=my_params){
  
  length_criteria<-my_params %>%
    dplyr::group_by(params_analyses)%>%
    dplyr::tally()%>%
    dplyr::mutate(total=sum(n))%>%
    dplyr::mutate(prop=n*100/total)

  
  print(paste0("From ",sum(lenght_criteria$n),' trips: ',
                round(lenght_criteria$prop[1],2),' (n = ',lenght_criteria$n[1],') were ',lenght_criteria$params_analyses[1],' and ',
                 round(lenght_criteria$prop[2],2),' (n = ',lenght_criteria$n[2],') were ',lenght_criteria$params_analyses[2],
                '. Evaluate if trips longer than 24 hrs is because of a change in central location'))
  
}
devtools::document()
devtools::check()
```

```{r}
check_length_criteria(my_params=Params_resolution)
```


# --------------------

# 4. Reevaluate trips

## Step 1: check outliers

Check big outliers

```{r}
head(Params_resolution)
```

```{r}
Reevaluate<-Params_resolution %>%
  dplyr::filter(params_analyses!='shorter_than_24h_keep_centralloc')
Reevaluate
```

Are this outliers due to gaps of the intervals?
Large intervals might cause that the bird entering back to the colony is missed.

```{r}
print(paste0("Max gaps was: ",
             round(Reevaluate$max_gap,2),
             ' mins. If the interval is more than 60 minutes in duration that could be a plausible explaination and then it should be eliminated. If the interval is less than 60 minutes in duration consider it can be a change in central location of the bird.'))
```

## Step 2: extract locs

Identify ids 

```{r}
Reevaluate_tripid<-unique(Reevaluate$trip_id)
Reevaluate_tripid
```

## Step 3: subset locations

```{r}
Reevaluate_01locs<-GSM_trips %>%
  dplyr::filter(trip_number %in% Reevaluate_tripid)%>%
  dplyr::relocate(ID,trip_number,daytime,gaps_min)
head(Reevaluate_01locs)
```

## Step 4: identify new central location

```{r}
my_central_location<-data.frame(Longitude=-110.33979846296234,Latitude=24.28728834326802)
```

```{r}
plot_check<-function(my_locs=my_locs,my_central_location=my_central_location){
  ggplot2::ggplot()+
  ggplot2::geom_point(data = my_locs, ggplot2::aes(x=Longitude, y = Latitude),
             color='black',size = 0.8,alpha=0.4)+
  ggplot2::geom_point(data=my_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='red',shape=17, size=5)+
  ggplot2::geom_density_2d_filled(data = my_locs, ggplot2::aes(x = Longitude, y = Latitude),alpha = 0.5)+
  ggplot2::theme_bw()+
  ggplot2::theme(legend.position = 'none')+
  ggplot2::ggtitle('Check that the triangle is close to the highest location concentration- \nThis should be your central location-  \nIf the central location is shifted -  \nPlease recalculate using another central location')}
```

```{r, fig.height=4}
plot_check(my_locs=Reevaluate_01locs,my_central_location = my_central_location)+
  ggplot2::facet_wrap(~trip_number)
```


```{r}
new_central_location<-data.frame(Longitude=-110.325,Latitude=24.17)
```

```{r, fig.height=4}
plot_check(my_locs=Reevaluate_01locs,my_central_location = my_central_location)+
  ggplot2::geom_point(data=new_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='blue',shape=17, size=5)
```



## Step 5: create_buffer

```{r, eval=FALSE, echo=FALSE}
usethis::use_r("create_buffer")

create_buffer<-function(central_point=central_point, buffer_km=buffer_km){
  central_spatial<- sp::SpatialPoints(cbind(central_point$Longitude,central_point$Latitude)) 
  sp::proj4string(central_spatial)= sp::CRS("+init=epsg:4326") 
  central_spatial <- sp::spTransform(central_spatial, sp::CRS("+init=epsg:4326"))
  central_spatial<-sf::st_as_sf(central_spatial)
  buffer_dist<-buffer_km*1000
  central_buffer<-sf::st_buffer(central_spatial, buffer_dist)
  return(central_buffer)
}

usethis::use_package("sf")
usethis::use_package("sp")

#' Creates a buffer around a point
#'
#' @param central_pont a data frame with latitude and longitude
#'
#' @return returns a buffer in spatial new_central_buffer
#' @export
#'
# @examples new_central_location<-data.frame(Longitude=-110.325,Latitude=24.17)
# new_central_buffer<-create_buffer(central_point=new_central_location,buffer_km=0.3)
create_buffer<-function(central_point=central_point, buffer_km=buffer_km){
  central_spatial<- sp::SpatialPoints(cbind(central_point$Longitude,central_point$Latitude))
  sp::proj4string(central_spatial)= sp::CRS("+init=epsg:4326")
  central_spatial <- sp::spTransform(central_spatial, sp::CRS("+init=epsg:4326"))
  central_spatial<-sf::st_as_sf(central_spatial)
  buffer_dist<-buffer_km*1000
  central_buffer<-sf::st_buffer(central_spatial, buffer_dist)
  return(central_buffer)
}
```

```{r}
new_central_buffer<-create_buffer(central_point=new_central_location,buffer_km=0.3)
```

## Step 6: from_df_to_sf

```{r}
Reevaluate_tripid<-'trip_00512'
```

```{r}
Reevaluate_01locs<-GSM_trips %>%
  dplyr::filter(trip_number %in% Reevaluate_tripid)%>%
  dplyr::relocate(ID,trip_number,daytime,gaps_min)
```

```{r,eval=FALSE, echo=FALSE}
Reevaluate_locs<-Reevaluate_01locs
#Move to folder data
save(Reevaluate_locs, file = "Reevaluate_locs.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("Reevaluate_locs")
devtools::document()
devtools::check()
```

```{r, eval=FALSE, echo=FALSE}
usethis::use_r("from_df_to_st")

from_df_to_st<-function(my_df){
  my_points <- my_df
  sp::coordinates(my_points) <- ~Longitude + Latitude
  sp::proj4string(my_points) = sp::CRS("+init=epsg:4326")
  my_sf<-sf::st_as_sf(my_points)
  return(my_sf)
}

usethis::use_package("sf")
usethis::use_package("sp")

#' Converts a data frame into a sf simple features, uses 4326 as CRS
#'
#' @param Reevaluate_locs a data frame with latitude and longitude
#'
#' @return returns a buffer in spatial new_central_buffer
#' @export
#'
# @examples from_df_to_st(Reevaluate_locs)
from_df_to_st<-function(my_df){
  my_points <- my_df
  sp::coordinates(my_points) <- ~Longitude + Latitude
  sp::proj4string(my_points) = sp::CRS("+init=epsg:4326")
  my_sf<-sf::st_as_sf(my_points)
  return(my_sf)
}
devtools::document()
```

```{r}
Reevaluate_02sf<-from_df_to_st(Reevaluate_locs)
```

## Step 7: over

```{r,eval=FALSE, echo=FALSE}
Reevaluate_sf<-Reevaluate_02sf
#Move to folder data
save(Reevaluate_sf, file = "Reevaluate_sf.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("Reevaluate_sf")
devtools::document()
devtools::check()
```

```{r}
new_central_location<-data.frame(Longitude=-110.325,Latitude=24.17)
```

```{r}
new_central_buffer<-create_buffer(central_point=new_central_location,buffer_km=0.3)
```

```{r,eval=FALSE, echo=FALSE}
Reevaluate_polygon<-new_central_buffer
#Move to folder data
save(Reevaluate_polygon, file = "Reevaluate_polygon.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("Reevaluate_polygon")
devtools::document()
devtools::check()
```

```{r, eval=FALSE,echo=FALSE}
over<-function(my_locations=my_locations,my_polygon=my_polygon){
  locations<-sf::st_as_sf(my_locations)
  location_over<-sapply(sf::st_intersects(locations,my_polygon), 
                        function(z) if (length(z)==0) NA_integer_ else z[1])
  return(location_over)}
usethis::use_r("over")

#' Gives information if the polygon intersects the locations or not
#'
#' @param my_locations s Simple feature with a data frame
#' @param my_polygon a Simple feature collection with 1 feature and 0 fields
#'
#' @return vector with data
#' @export
#'
# @examples over(my_locations=Reevaluate_sf,my_polygon=Reevaluate_polygon)
over<-function(my_locations=my_locations,my_polygon=my_polygon){
  locations<-sf::st_as_sf(my_locations)
  location_over<-sapply(sf::st_intersects(locations,my_polygon),
                        function(z) if (length(z)==0) NA_integer_ else z[1])
  return(location_over)}
```

Check nrows should correspond.

```{r}
Reevaluate_locs<-Reevaluate_locs
Reevaluate_sf<-Reevaluate_sf
Reevaluate_polygon<-Reevaluate_polygon
```

```{r}
Reevaluate_locs$central_location<- over(my_locations=Reevaluate_sf,my_polygon=Reevaluate_polygon)
```

## Step 8: add_trip_number

```{r,eval=FALSE, echo=FALSE}
Reevaluate_trips<-Reevaluate_locs
#Move to folder data
save(Reevaluate_trips, file = "Reevaluate_trips.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("Reevaluate_trips")
devtools::document()
devtools::check()
```

```{r}
Reevaluate_trips<-Reevaluate_trips
```

```{r}
Previous_params<-data.frame(trip_id=c("trip_00405"))
```

```{r}
new_trip_number_sequence<-continue_trip_sequence(my_previous=data.frame(trip_id=c("trip_00405")))
```

```{r, eval=FALSE, echo=FALSE}
add_trip_number<-function(my_df,my_trip_number_sequence){
  
  my_df<-my_df %>%
     dplyr::mutate(inside= dplyr::case_when(central_location == 1 ~ 'inside_central',TRUE ~ 'outside_central'))
  
  my_df %>%
     dplyr::group_by(ID,inside)%>%
     dplyr::count()%>%
     tidyr::pivot_wider(names_from = inside, values_from = n)
  
  my_outside<-my_df %>%
     dplyr::filter(inside=='outside_central')
  
  my_trips<-my_outside %>%
     dplyr::mutate(num_seq=as.numeric(num_seq))%>%
     dplyr::mutate(trip_number = (cumsum(c(1L, diff(num_seq)) !=   1L)))%>%
     dplyr::mutate(trip_number = trip_number + 1 + my_trip_number_sequence)%>%
     dplyr::mutate(trip_number = stringr::str_pad(trip_number,  5, pad = "0"))%>%
     dplyr::mutate(trip_number = paste0("trip_", trip_number))
  
  return(my_trips)
}

usethis::use_r("add_trip_number")

#' Add trip number to a series of locations using a base if the animal move or not outside of the buffer
#'
#' @param my_df A data frame with central_location and num_sequence
#' @param my_trip_number_sequence a number to continue trip sequence
#'
#' @return vector with data
#' @export
#'
# @examples add_trip_number(my_df=Reevaluate_trips,my_trip_number_sequence=405)
add_trip_number<-function(my_df,my_trip_number_sequence){
  
  my_df<-my_df %>%
     dplyr::mutate(inside= dplyr::case_when(central_location == 1 ~ 'inside_central',TRUE ~ 'outside_central'))
  
  my_df %>%
     dplyr::group_by(ID,inside)%>%
     dplyr::count()%>%
     tidyr::pivot_wider(names_from = inside, values_from = n)
  
  my_outside<-my_df %>%
     dplyr::filter(inside=='outside_central')
  
  my_trips<-my_outside %>%
     dplyr::mutate(num_seq=as.numeric(num_seq))%>%
     dplyr::mutate(trip_number = (cumsum(c(1L, diff(num_seq)) !=   1L)))%>%
     dplyr::mutate(trip_number = trip_number + 1 + my_trip_number_sequence)%>%
     dplyr::mutate(trip_number = stringr::str_pad(trip_number,  5, pad = "0"))%>%
     dplyr::mutate(trip_number = paste0("trip_", trip_number))
  
  return(my_trips)
}
```
```{r}
Reevaluate_04trips<-add_trip_number(my_df=Reevaluate_trips,
                                    my_trip_number_sequence=new_trip_number_sequence)
```

```{r, fig.height=4}
plot_trips<-function(my_locs=my_locs,my_central_location=my_central_location){
  ggplot2::ggplot()+
  ggplot2::geom_point(data = my_locs, ggplot2::aes(x=Longitude, y = Latitude,color=trip_number),
            size = 0.8,alpha=0.4)+
  ggplot2::geom_point(data=my_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='red',shape=17, size=5)+
  ggplot2::geom_density_2d_filled(data = my_locs, ggplot2::aes(x = Longitude, y = Latitude),alpha = 0.1)+
  ggplot2::theme_bw()+
  ggplot2::theme(legend.position = 'none')+
  ggplot2::ggtitle('Here excludes all nest locations \nCheck if there is any pattern that suggest that the central location is shifted \nThis would include hotstops (brighter colors) in a specific area')}
```

```{r}
new_central_location<-data.frame(Longitude=-110.325,Latitude=24.17)
```

```{r}
plot_trips(my_locs=Reevaluate_04trips,my_central_location=new_central_location)
```


## Step 9: calculate params

```{r}
Reevaluate_05params<-calculate_params(my_locs=Reevaluate_04trips,
                                 my_daytime='daytime',
                                 my_format=  "%Y-%m-%d %H:%M:%S",
                                 my_units="hours",
                                 my_separator="trip_number")
head(Reevaluate_05params)
```

```{r}
This_month<-'08'
This_month_text<-'Ago'
```

```{r}
Reevaluate_05params<-Reevaluate_05params %>%
  dplyr::mutate(trip_month_id=paste0(This_month_text,"_b_",trip_id))%>%
  dplyr::mutate(central_loc='south_of_colony')
```

```{r, fig.height=4}
hist(Reevaluate_05params$duration)
```

## Step 10: plot_trips

```{r}
plot_trips(my_locs=Reevaluate_04trips,my_central_location = new_central_location)+
  ggplot2::geom_point(data=new_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='blue',shape=17, size=5)
```

## Step 11: classify params

```{r}
Params_03reevaluate<-classify_params(my_params=Reevaluate_05params)
```

# --------------------

# 5. Merge 

## Step 1: Merge params

Add criteria classifications

```{r}
Params_02criteria
Params_03reevaluate
```

```{r}
Params_merged<-rbind(Params_02criteria %>% dplyr::filter(!trip_id %in% Reevaluate_tripid),
                     Params_03reevaluate)
```

## Step 2: Locs merged

```{r}
GSM_trips
Reevaluate_04trips
```

```{r}
Locs_merged <-rbind(GSM_trips %>% 
                      dplyr::filter(!trip_number %in% Reevaluate_tripid)%>%
                      dplyr::select(ID,daytime,season,month,
                             Longitude,Latitude,
                             central_base,inside,num_seq,
                             gaps_min,battery_charge,
                             trip_number),
                    
                    Reevaluate_04trips %>%
                      dplyr::select(ID,daytime,season,month,
                             Longitude,Latitude,
                             central_base,inside,num_seq,
                             gaps_min,battery_charge,
                             trip_number))
```


# --------------------

# 6. Candidates for interpolation

Whether to interpolate the data depends on your research goals and the nature of the gaps.

Here’s a breakdown of considerations to help you decide:

- Short Gaps: If the gaps are short (e.g., a few minutes to an hour), interpolation might be justifiable, especially if you assume that the bird's movement is relatively constant during the gap. For example, linear interpolation can estimate a reasonable position based on previous and subsequent data points.
- Long Gaps: If the gaps are long (e.g., several hours or days), interpolation might introduce unrealistic results, especially if the bird’s movement during that time period was unknown. Interpolating long gaps could lead to misleading conclusions about the bird’s actual path or behavior.
If your study’s analysis can handle missing data or gaps (e.g., for high-level migration patterns), you might consider leaving the gaps unfilled. This avoids the risk of introducing erroneous data but may reduce the overall precision.
If your analysis is based on trajectory or movement behavior, you could use gap-filling approaches like predicting the bird’s behavior based on its last known location and surrounding environmental context (such as weather, time of day, etc.).


```{r}
Inter_params<-Params_resolution
Inter_locs<-GSM_trips
```

## Step 1: exclude trips longer than 24 hrs with gaps larger than 60 minutes

```{r}
Inter_params %>%
  dplyr::group_by(interpolation)%>%
  dplyr::tally()
```

```{r}
Inter_01params<-Inter_params %>%
  dplyr::filter(interpolation=='gapsless60mins_shorter24hr_canditate_interpolate')
```

```{r,eval=FALSE, echo=FALSE}
Interpolation_params<-Inter_01params
#Move to folder data
save(Interpolation_params, file = "Interpolation_params.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("Interpolation_params")
devtools::document()
devtools::check()
```

## Step 2: classify_locs

```{r, eval=FALSE,echo=FALSE}
classify_locs<-function(Inter_params=Inter_params,
                     Inter_locs=Inter_locs){
  
  tripid_01trip_size<-unique(Inter_params %>%
                            dplyr::filter(trip_size == 'trip_longer_than_30mins'))$trip_id
  
  tripid_02analysesid<-unique(Inter_params %>%
                                dplyr::filter(params_analyses == "shorter_than_24h_keep_centralloc"))$trip_id
  
  tripid_03resolutionid<-unique(Inter_params %>%
                                  dplyr::filter(resolution == "ok_resolution_gaps_less_60_mins"))$trip_id
  
  tripid_04interpolateid<-unique(Inter_params %>%
                                   dplyr::filter(interpolation == 'gapsless60mins_shorter24hr_canditate_interpolate'))$trip_id
  
  Inter_locs<-Inter_locs %>%
  dplyr::mutate(trip_size = 
                  dplyr::case_when(trip_number %in% tripid_01trip_size ~  'trip_longer_than_30mins',
                                 TRUE ~  'trip_shorter_than_30mins'))%>%
  
  dplyr::mutate(params_analyses=
                  dplyr::case_when(trip_number %in% tripid_02analysesid ~ "keep_centralloc_shorter_than_24h",
                          TRUE ~ "reevaluate_centralloc_longer_than_24h"))%>%
  
  dplyr::mutate(resolution=
                  dplyr::case_when(trip_number %in% tripid_03resolutionid~ "ok_resolution_gaps_less_60_mins",
                          TRUE ~ "low_resolution_gaps_more_60_mins"))%>%
  
  dplyr::mutate(interpolation=
                  dplyr::case_when(trip_number %in% tripid_04interpolateid ~ 'gapsless60mins_shorter24hr_canditate_interpolate',
                          TRUE ~ "dont_interpolate_longer24hr"))
  
  return(Inter_locs)
}

usethis::use_r("classify_locs")
# Run in console
devtools::document()
devtools::check()
```

```{r}
Inter_02locs<-classify_locs(Inter_params=Interpolation_params,
                            Inter_locs=GSM_trips)
```

```{r}
Inter_02locs %>%
  dplyr::group_by(trip_size)%>%
  dplyr::tally()
```

## Step 3: check locations

The part of dont interpolate would be large because it includes resting and overnight locations

```{r}
Inter_02locs %>%
  dplyr::group_by(interpolation)%>%
  dplyr::tally()
```

```{r}
plot_trips<-function(my_locs=my_locs,my_central_location=my_central_location){
  ggplot2::ggplot()+
  ggplot2::geom_point(data = my_locs, ggplot2::aes(x=Longitude, y = Latitude,color=trip_number),
            size = 0.8,alpha=0.4)+
  ggplot2::geom_point(data=my_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='red',shape=17, size=5)+
  ggplot2::geom_density_2d_filled(data = my_locs, ggplot2::aes(x = Longitude, y = Latitude),alpha = 0.1)+
  ggplot2::theme_bw()+
  ggplot2::theme(legend.position = 'none')+
  ggplot2::ggtitle('Here excludes all nest locations \nCheck if there is any pattern that suggest that the central location is shifted \nThis would include hotstops (brighter colors) in a specific area')}
```

```{r}
my_central_location<-data.frame(Longitude=-110.33979846296234,Latitude=24.28728834326802)
```

```{r}
plot_trips(my_locs=Inter_02locs,my_central_location = my_central_location)
```

## Step 4: check included

```{r}
Inter_03included <- Inter_02locs %>%
  dplyr::filter(interpolation == 'gapsless60mins_shorter24hr_canditate_interpolate')
```

```{r, fig.height=4}
plot_trips(my_locs=Inter_03included,my_central_location = my_central_location)
```

## Step 5: check excluded

```{r}
Inter_04excluded <- Inter_02locs %>%
  #dplyr::filter(trip_size == 'trip_longer_than_30mins')%>%
  dplyr::filter(interpolation != 'gapsless60mins_shorter24hr_canditate_interpolate')
```

```{r, eval=FALSE, fig.height=20, fig.width=20}
plot_trips(my_locs=Inter_04excluded,my_central_location = my_central_location)+
  ggplot2::facet_wrap(~trip_number)
```



Trip 445
Trip 508 
Trip 512
Trip 518 
Trip 528 Seem legit, and maybe should be reconsidered if central location is identified. 
Look genuinely that the bird change location.

```{r}
this_trip<-'trip_00512'
```

```{r}
Inter_params %>%
  dplyr::filter(trip_id==this_trip)
```

```{r}
Inter_05reevaluate<-Inter_04excluded %>%
  dplyr::filter(trip_number==this_trip)
```

```{r}
dplyr::first(Inter_05reevaluate$daytime)
dplyr::last(Inter_05reevaluate$daytime)
```

## Step 6: new central location

```{r}
plot_check<-function(my_locs=my_locs,my_central_location=my_central_location){
  ggplot2::ggplot()+
  ggplot2::geom_point(data = my_locs, ggplot2::aes(x=Longitude, y = Latitude),
             color='black',size = 0.8,alpha=0.4)+
  ggplot2::geom_point(data=my_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='red',shape=17, size=5)+
  ggplot2::geom_density_2d_filled(data = my_locs, ggplot2::aes(x = Longitude, y = Latitude),alpha = 0.5)+
  ggplot2::theme_bw()+
  ggplot2::theme(legend.position = 'none')+
  ggplot2::ggtitle('Check that the triangle is close to the highest location concentration- \nThis should be your central location-  \nIf the central location is shifted -  \nPlease recalculate using another central location')}
```

```{r}
new_central_location<-data.frame(Longitude=-110.325,Latitude=24.17)
plot_check(my_locs=Inter_05reevaluate,my_central_location = new_central_location)+
  ggplot2::geom_point(data=new_central_location, ggplot2::aes(x=Longitude, y=Latitude),color='red',shape=17, size=5)
```

## Step 7: reevaluate_params

```{r}
Inter_05reevaluate
```

```{r}
this_locs=Inter_05reevaluate
this_central_location=new_central_location
this_previous=Inter_params
```

```{r}
recalculate_params<-function(this_locs,
                            this_central_location,
                            this_previous){
  
## create_buffer
my_central_buffer<-create_buffer(central_point=this_central_location,buffer_km=0.3)

## from_df_to_sf
my_sf<-from_df_to_st(this_locs)

## over
my_over<- over(my_locations=my_sf,my_polygon=my_central_buffer)
this_locs$central_location<-my_over

## continue_trip_sequence
my_trip_number_sequence<-continue_trip_sequence(my_previous=this_previous$trip_id)

## add_trip_number
my_trips<-add_trip_number(my_df=this_locs,
                          my_trip_number_sequence=my_trip_number_sequence)

## calculate_params
my_params<-calculate_params(my_locs=my_trips,
                                 my_daytime='daytime',
                                 my_format=  "%Y-%m-%d %H:%M:%S",
                                 my_units="hours",
                                 my_separator="trip_number")

return(my_params)}
```

```{r}
Inter_06params<-recalculate_params(this_locs=Inter_05reevaluate,
                                   this_central_location=new_central_location,
                                   this_previous=Inter_params)
Inter_06params
```

```{r}
This_month_text<-"Ago"
```

```{r}
Inter_06params<-Inter_06params%>%
  dplyr::mutate(trip_month_id=paste0(This_month_text,"_c_",trip_id))%>%
  dplyr::mutate(central_loc='south_of_colony')
Inter_06params
```

# --------------------

# 7. Interpolation

## Step 1: interpolate

```{r,eval=FALSE, echo=FALSE}
Interpolation_trips<-Inter_03included
#Move to folder data
save(Interpolation_trips, file = "Interpolation_trips.RData", version = 2)
#Run in console, not Rmd
usethis::use_r("Interpolation_trips")
devtools::document()
devtools::check()
```

```{r, eval=FALSE,echo=FALSE}
interpolate_trips<-function(my_df=my_df,
                            interval=interval,
                            column_datetime=column_datetime,
                            datetime_format=datetime_format,
                            column_lat=column_lat,
                            column_lon=column_lon,
                            column_trip=column_trip){
  
  
  Inter_df <- my_df
  
  # Prepare columns
  Inter_df$dt <- Inter_df[[column_datetime]]
  Inter_df$dt<-as.POSIXct(strptime(Inter_df$dt,datetime_format),tz = "GMT")
  
  Inter_df$Longitude <- Inter_df[[column_lon]]
  Inter_df$Latitude <- Inter_df[[column_lat]]
  Inter_df$trip_number <- Inter_df[[column_trip]]
  
  # Loop
  Trips_ls<-split(Inter_df,Inter_df$trip_number)
  
  for( i in seq_along(Trips_ls)){
    Trip_df <- Trips_ls[[i]] 
    
    # Longitude, make sure the column name corresponds, and dt must be in the right format
    New_longitude0 <- stats::approx(Trip_df$dt, Trip_df$Longitude,
                                    xout = seq(min(Trip_df$dt), max(Trip_df$dt), by = interval))
    New_longitude1 <- data.frame(x = New_longitude0$x, y = New_longitude0$y)
    
    # Latitude, make sure the column name corresponds
    New_latitude0 <- stats::approx(Trip_df$dt, Trip_df$Latitude, 
                                   xout = seq(min(Trip_df$dt), max(Trip_df$dt), by = interval))
    New_latitude1 <- data.frame(x = New_latitude0$x, y = New_latitude0$y)
    
    # Bind
    New_coords <- cbind(New_longitude1, New_latitude1)
    New_coords$trip_number <- unique(Trip_df$trip_number)
    
    trip_number<-'trip_number'
    DateTimeGMT<-'DateTimeGMT'
    Latitude<-'Latitude'
    Longitude<-'Longitude'
    
    colnames(New_coords)[1]<-DateTimeGMT
    colnames(New_coords)[2]<-Longitude
    colnames(New_coords)[4]<-Latitude
    colnames(New_coords)[5]<-trip_number
    
    
    New_coords <- New_coords[,c('trip_number','DateTimeGMT',"Longitude","Latitude")]
    
    Trips_ls[[i]]<- New_coords}
  
  Trips_interp <- do.call("rbind",Trips_ls)
  rownames(Trips_interp) <- NULL
  
  return(Trips_interp)
}
```

```{r}
Interpolated_locs<-interpolate_trips(my_df=Interpolation_trips,
                                    interval='900 sec',
                                    column_datetime='daytime',
                                    column_trip='trip_number',
                                    column_lat='Latitude',
                                    column_lon='Longitude',
                                    datetime_format="%Y-%m-%d %H:%M:%S")
```


# end of document
